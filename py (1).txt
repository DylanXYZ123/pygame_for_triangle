import pygame
import math
import sys
pygame.init()
COLORS = {
    'bg': (212, 212, 216),        
    'card': (255, 255, 255),      
    'canvas_bg': (240, 240, 240), 
    'grid': (100, 100, 100),      
    'text': (45, 55, 72),         
    'red': (255, 0, 85),          
    'blue': (0, 85, 255),        
    'green': (0, 170, 0),        
    'purple': (170, 0, 170),      
    'yellow': (251, 191, 36),    
    'black': (0, 0, 0),
}




SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 650
SCREEN = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Pixel Geometry: Triangle Centers (Pygame)")




# 畫布區域
CANVAS_WIDTH = 800
CANVAS_HEIGHT = 600
CANVAS_X = SCREEN_WIDTH - CANVAS_WIDTH - 20
CANVAS_Y = 25


# --- 字體兼容性修復區 (保留) ---
CHINESE_FONTS = [
    'Microsoft JhengHei', 'Arial Unicode MS', 'Noto Sans CJK TC', 
    'PingFang TC', 'Heiti TC', 'WenQuanYi Zen Hei', 'SimHei', 
    'sans-serif', 'monospace',
]


def get_chinese_font(size):
    """嘗試尋找系統中可用的中文字體，否則使用 Pygame 預設字體"""
    best_match = None
    for font_name in CHINESE_FONTS:
        matched_path = pygame.font.match_font(font_name, bold=False, italic=False)
        if matched_path:
            best_match = matched_path
            break
            
    if best_match:
        try:
            return pygame.font.Font(best_match, size)
        except pygame.error:
            # 載入失敗，退回預設字體
            return pygame.font.SysFont(None, size)
    else:
        # 所有字體都找不到，使用 Pygame 預設字體
        return pygame.font.SysFont(None, size)


# 載入不同大小的字體
FONT_L = get_chinese_font(28)
FONT_M = get_chinese_font(22)
FONT_S = get_chinese_font(16)
# --- 字體兼容性修復區結束 ---




# 頂點結構 (未變動)
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y


# 初始頂點
INITIAL_POINTS = [
    Point(CANVAS_WIDTH // 2, 150), 
    Point(CANVAS_WIDTH // 2 - 200, 450), 
    Point(CANVAS_WIDTH // 2 + 200, 450), 
]


# --- 幾何計算函式庫 (未變動) ---


def dist(p1, p2):
    """計算兩點間距離"""
    return math.sqrt(math.pow(p1.x - p2.x, 2) + math.pow(p1.y - p2.y, 2))


def midpoint(p1, p2):
    """計算中點"""
    return Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)


def get_angles(p):
    """計算三角形內角 (A, B, C)"""
    a = dist(p[1], p[2])
    b = dist(p[0], p[2])
    c = dist(p[0], p[1])
    
    if a == 0 or b == 0 or c == 0:
        return [0, 0, 0]


    try:
        val_a = max(-1.0, min(1.0, (b*b + c*c - a*a) / (2*b*c)))
        val_b = max(-1.0, min(1.0, (a*a + c*c - b*b) / (2*a*c)))
        val_c = max(-1.0, min(1.0, (a*a + b*b - c*c) / (2*a*b)))
        
        angA = math.acos(val_a)
        angB = math.acos(val_b)
        angC = math.acos(val_c)
    except Exception: 
        angA = angB = angC = 0


    return [angA * (180 / math.pi), angB * (180 / math.pi), angC * (180 / math.pi)]


def get_angle_label_pos(curr, p1, p2, offset=60):
    """計算角度標籤的位置"""
    v1 = Point(p1.x - curr.x, p1.y - curr.y)
    v2 = Point(p2.x - curr.x, p2.y - curr.y)
    len1 = dist(Point(0, 0), v1)
    len2 = dist(Point(0, 0), v2)


    if len1 == 0 or len2 == 0: return Point(curr.x, curr.y - offset)


    bisector = Point((v1.x / len1) + (v2.x / len2), (v1.y / len1) + (v2.y / len2))
    b_len = dist(Point(0, 0), bisector)


    if b_len == 0: 
        return Point(curr.x + v1.x / len1 * offset, curr.y + v1.y / len1 * offset)


    return Point(
        curr.x + (bisector.x / b_len) * offset,
        curr.y + (bisector.y / b_len) * offset
    )


def get_centroid(p):
    """計算重心 (G)"""
    return Point(
        (p[0].x + p[1].x + p[2].x) / 3,
        (p[0].y + p[1].y + p[2].y) / 3
    )


def get_circumcenter(p):
    """計算外心 (O)"""
    A, B, C = p[0], p[1], p[2]
    D = 2 * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))
    if D == 0: return None
    
    A_sq = A.x**2 + A.y**2
    B_sq = B.x**2 + B.y**2
    C_sq = C.x**2 + C.y**2


    Ux = (1 / D) * (A_sq * (B.y - C.y) + B_sq * (C.y - A.y) + C_sq * (A.y - B.y))
    Uy = (1 / D) * (A_sq * (C.x - B.x) + B_sq * (A.x - C.x) + C_sq * (B.x - A.x))
    return Point(Ux, Uy)


def get_orthocenter(p):
    """計算垂心 (H)"""
    G = get_centroid(p)
    O = get_circumcenter(p)
    if not O: return G 


    return Point(
        3 * G.x - 2 * O.x,
        3 * G.y - 2 * O.y
    )


def get_incenter(p):
    """計算內心 (I)"""
    a = dist(p[1], p[2])
    b = dist(p[0], p[2])
    c = dist(p[0], p[1])
    perimeter = a + b + c
    
    if perimeter == 0: return p[0]


    return Point(
        (a * p[0].x + b * p[1].x + c * p[2].x) / perimeter,
        (a * p[0].y + b * p[1].y + c * p[2].y) / perimeter
    )


def get_projection(P, A, B):
    """計算點 P 在直線 AB 上的投影點"""
    atob = Point(B.x - A.x, B.y - A.y)
    atop = Point(P.x - A.x, P.y - A.y)
    len2 = atob.x * atob.x + atob.y * atob.y
    
    if len2 == 0: return A
    
    dot = atop.x * atob.x + atop.y * atob.y
    t = dot / len2
    
    return Point(
        A.x + atob.x * t,
        A.y + atob.y * t
    )


# --- 繪圖工具 ---


def to_screen(p):
    """將畫布座標轉換為螢幕座標，並確保座標點為**整數**"""
    return (int(round(p.x + CANVAS_X)), int(round(p.y + CANVAS_Y)))


def draw_pixel_point(surface, center_point, color, label, size=6):
    """繪製像素風格的幾何中心點"""
    rect = pygame.Rect(center_point[0] - size, center_point[1] - size, size * 2, size * 2)
    
    pygame.draw.rect(surface, color, rect)
    pygame.draw.rect(surface, COLORS['black'], rect, 2)


    text_surf = FONT_M.render(label, True, COLORS['black'])
    text_rect = text_surf.get_rect(midleft=(center_point[0] + size + 5, center_point[1]))
    surface.blit(text_surf, text_rect)


def draw_button(surface, rect, label, color):
    """繪製像素風格的按鈕/切換開關"""
    shadow_rect = rect.move(4, 4)
    pygame.draw.rect(surface, COLORS['black'], shadow_rect)
    
    pygame.draw.rect(surface, color, rect)
    pygame.draw.rect(surface, COLORS['black'], rect, 3)


    text_surf = FONT_M.render(label, True, COLORS['black'])
    text_rect = text_surf.get_rect(center=rect.center)
    surface.blit(text_surf, text_rect)
    
    return rect


# --- 應用程式狀態 (未變動) ---
class AppState:
    def __init__(self):
        self.points = [Point(p.x, p.y) for p in INITIAL_POINTS]
        self.dragging_idx = None
        self.offset_x, self.offset_y = 0, 0
        self.toggles = {
            'angles': True,
            'centroid': False,
            'circumcenter': False,
            'orthocenter': False,
            'incenter': False,
        }
        self.button_rects = {} 


    def reset_points(self):
        self.points = [Point(p.x, p.y) for p in INITIAL_POINTS]


    def set_equilateral(self):
        h = 300 * (math.sqrt(3) / 2)
        cy = CANVAS_HEIGHT / 2
        cx = CANVAS_WIDTH / 2
        self.points = [
            Point(cx, cy - h / 2),
            Point(cx - 150, cy + h / 2),
            Point(cx + 150, cy + h / 2),
        ]


    def set_isosceles_right(self):
        self.points = [
            Point(250, 150), 
            Point(250, 450), 
            Point(550, 450), 
        ]
        
    def set_isosceles(self):
        self.points = [
            Point(400, 150), 
            Point(250, 450), 
            Point(550, 450), 
        ]


# --- 主繪圖迴圈 ---


def draw_ui(surface, state):
    """繪製控制面板和資訊"""
    
    # 左側控制面板背景 - 寬度調整為 300
    PANEL_WIDTH = 300
    panel_rect = pygame.Rect(20, CANVAS_Y, PANEL_WIDTH, 600)
    pygame.draw.rect(surface, COLORS['black'], panel_rect.move(6, 6))
    pygame.draw.rect(surface, COLORS['card'], panel_rect)
    pygame.draw.rect(surface, COLORS['black'], panel_rect, 4)
    
    # 標題
    title_surf = FONT_L.render("#設定", True, COLORS['black'])
    surface.blit(title_surf, (panel_rect.x + 20, panel_rect.y + 20))
    
    # 繪製切換開關
    y_start = panel_rect.y + 80
    toggle_options = [
        ('angles', '角度 (∠)', '顯示度數', COLORS['yellow']),
        ('centroid', '重心 (G)', '質量中心', COLORS['red']),
        ('circumcenter', '外心 (O)', '外接圓心', COLORS['blue']),
        ('orthocenter', '垂心 (H)', '高線交點', COLORS['green']),
        ('incenter', '內心 (I)', '內切圓心', COLORS['purple']),
    ]
    
    state.button_rects = {}
    
    for i, (key, label, desc, color) in enumerate(toggle_options):
        # 調整開關寬度以適應面板
        toggle_rect = pygame.Rect(panel_rect.x + 10, y_start + i * 65, panel_rect.width - 20, 60)
        
        if key in state.toggles and state.toggles[key]: 
            pygame.draw.rect(surface, color, toggle_rect)
            pygame.draw.rect(surface, COLORS['black'], toggle_rect, 3)
            pygame.draw.rect(surface, COLORS['card'], toggle_rect.inflate(-4, -4))
        else:
            pygame.draw.rect(surface, COLORS['black'], toggle_rect.move(4, 4))
            pygame.draw.rect(surface, COLORS['card'], toggle_rect)
            pygame.draw.rect(surface, COLORS['black'], toggle_rect, 2)


        label_surf = FONT_M.render(label, True, COLORS['text'])
        desc_surf = FONT_S.render(desc, True, (150, 150, 150))
        surface.blit(label_surf, (toggle_rect.x + 10, toggle_rect.y + 8))
        # 描述文字調整到更左邊，以爭取空間
        surface.blit(desc_surf, (toggle_rect.x + 10, toggle_rect.y + 35))
        
        # LED 指示燈保持在右側
        led_color = color if key in state.toggles and state.toggles[key] else (200, 200, 200)
        pygame.draw.rect(surface, led_color, (toggle_rect.right - 40, toggle_rect.centery - 10, 20, 20))
        pygame.draw.rect(surface, COLORS['black'], (toggle_rect.right - 40, toggle_rect.centery - 10, 20, 20), 2)
        
        state.button_rects[key] = toggle_rect


    # 特殊形狀按鈕
    y_shapes = y_start + len(toggle_options) * 65 + 10
    pygame.draw.line(surface, COLORS['black'], (panel_rect.x + 10, y_shapes), (panel_rect.right - 10, y_shapes), 3)


    shape_buttons = [
        ('equilateral', '正三角形'),
        ('iso_right', '等腰直角'),
        ('isosceles', '等腰三角形'),
    ]
    
    for i, (key, label) in enumerate(shape_buttons):
        # 按鈕寬度也調整為 PANEL_WIDTH - 40
        btn_rect = pygame.Rect(panel_rect.x + 20, y_shapes + 30 + i * 45, panel_rect.width - 40, 40)
        draw_button(surface, btn_rect, "► " + label, (243, 244, 246))
        state.button_rects[key] = btn_rect


    # 重置按鈕
    reset_rect = pygame.Rect(panel_rect.x + 20, panel_rect.bottom - 60, panel_rect.width - 40, 50)
    draw_button(surface, reset_rect, "重設 (RESET)", (252, 165, 165)) 
    state.button_rects['reset'] = reset_rect
    
    # 資訊卡片
    # 由於面板變窄，資訊卡片也要跟著變窄
    info_rect = pygame.Rect(panel_rect.x, panel_rect.y - 100, panel_rect.width, 100)
    info_flag_rect = pygame.Rect(info_rect.x + 10, info_rect.y - 30, 80, 25)
    pygame.draw.rect(surface, COLORS['yellow'], info_flag_rect)
    pygame.draw.rect(surface, COLORS['black'], info_flag_rect, 2)
    flag_surf = FONT_S.render("資訊", True, COLORS['black'])
    surface.blit(flag_surf, flag_surf.get_rect(center=info_flag_rect.center))
    
    info_text = "拖曳頂點 (A, B, C) 來探索幾何中心點。"
    text_surf = FONT_M.render(info_text, True, COLORS['text'])
    surface.blit(text_surf, (info_rect.x + 10, info_rect.y))




def draw_canvas(surface, state):
    """繪製幾何畫布"""
    
    canvas_rect = pygame.Rect(CANVAS_X, CANVAS_Y, CANVAS_WIDTH, CANVAS_HEIGHT)


    # 畫布背景 (使用新的亮色)
    pygame.draw.rect(surface, COLORS['black'], canvas_rect)
    
    # 繪製網格 )
    GRID_COLOR = COLORS['black']
    for i in range(0, CANVAS_WIDTH, 20):
        start_x = CANVAS_X + i
        pygame.draw.line(surface, GRID_COLOR, (start_x, CANVAS_Y), (start_x, CANVAS_Y + CANVAS_HEIGHT), 1)
    for j in range(0, CANVAS_HEIGHT, 20):
        start_y = CANVAS_Y + j
        pygame.draw.line(surface, GRID_COLOR, (CANVAS_X, start_y), (CANVAS_X + CANVAS_WIDTH, start_y), 1)


    # 畫布邊框和陰影
    pygame.draw.rect(surface, COLORS['card'], canvas_rect.move(6, 6))
    pygame.draw.rect(surface, COLORS['card'], canvas_rect, 4)


    p = state.points
    A, B, C = p[0], p[1], p[2]


    # --- 幾何計算 ---
    G = get_centroid(p)
    O = get_circumcenter(p)
    H = get_orthocenter(p)
    I = get_incenter(p)
    
    M_BC = midpoint(B, C)
    M_AC = midpoint(A, C)
    M_AB = midpoint(A, B)
    P_A = get_projection(A, B, C)
    P_B = get_projection(B, A, C)
    P_C = get_projection(C, A, B)
    
    # --- 繪製幾何輔助線 ---


    # 重心線 (中線)
    if state.toggles['centroid']:
        draw_dashed_line(surface, COLORS['red'], to_screen(A), to_screen(M_BC), 3, 8)
        draw_dashed_line(surface, COLORS['red'], to_screen(B), to_screen(M_AC), 3, 8)
        draw_dashed_line(surface, COLORS['red'], to_screen(C), to_screen(M_AB), 3, 8)


    # 外心線 (中垂線)
    if state.toggles['circumcenter'] and O:
        draw_dashed_line(surface, COLORS['blue'], to_screen(M_BC), to_screen(O), 3, 8)
        draw_dashed_line(surface, COLORS['blue'], to_screen(M_AC), to_screen(O), 3, 8)
        draw_dashed_line(surface, COLORS['blue'], to_screen(M_AB), to_screen(O), 3, 8)
        
        # 外接圓
        r_out = dist(O, A)
        if r_out < CANVAS_WIDTH * 2: 
            pygame.draw.circle(surface, COLORS['blue'], to_screen(O), int(round(r_out)), 4)


    # 垂心線 (高)
    if state.toggles['orthocenter']:
        draw_dashed_line(surface, COLORS['green'], to_screen(A), to_screen(P_A), 3, 4)
        draw_dashed_line(surface, COLORS['green'], to_screen(B), to_screen(P_B), 3, 4)
        draw_dashed_line(surface, COLORS['green'], to_screen(C), to_screen(P_C), 3, 4)


    # 內心線 (角平分線)
    if state.toggles['incenter'] and I:
        draw_dashed_line(surface, COLORS['purple'], to_screen(A), to_screen(I), 3, 2)
        draw_dashed_line(surface, COLORS['purple'], to_screen(B), to_screen(I), 3, 2)
        draw_dashed_line(surface, COLORS['purple'], to_screen(C), to_screen(I), 3, 2)
        
        # 內切圓
        try:
            s_val = (dist(A, B) + dist(B, C) + dist(A, C)) / 2
            area = abs((A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y))/2)
            r_in = area / s_val
            pygame.draw.circle(surface, COLORS['purple'], to_screen(I), int(round(r_in)), 4)
        except ZeroDivisionError:
            pass 


    # --- 主三角形 (黑色超粗框 - 高對比) ---
    polygon_points = [to_screen(A), to_screen(B), to_screen(C)]
    # 線條粗細為 8
    pygame.draw.polygon(surface, COLORS['black'], polygon_points, 8) 


    # --- 繪製特殊中心點 ---
    if state.toggles['centroid'] and G: draw_pixel_point(surface, to_screen(G), COLORS['red'], "G")
    if state.toggles['circumcenter'] and O: draw_pixel_point(surface, to_screen(O), COLORS['blue'], "O")
    if state.toggles['orthocenter'] and H: draw_pixel_point(surface, to_screen(H), COLORS['green'], "H")
    if state.toggles['incenter'] and I: draw_pixel_point(surface, to_screen(I), COLORS['purple'], "I")


    # --- 繪製頂點和角度 ---
    angle_values = get_angles(p)
    
    for i in range(3):
        pt = p[i]
        label = chr(65 + i) # A, B, C
        
        # 繪製頂點
        point_size = 12
        point_center = to_screen(pt)
        
        # 拖曳陰影
        pygame.draw.rect(surface, (100, 100, 100), (point_center[0] - point_size + 4, point_center[1] - point_size + 4, point_size * 2, point_size * 2))


        # 主體方塊
        point_color = COLORS['card'] if state.dragging_idx == i else COLORS['black']
        pygame.draw.rect(surface, point_color, (point_center[0] - point_size, point_center[1] - point_size, point_size * 2, point_size * 2))
        pygame.draw.rect(surface, COLORS['black'], (point_center[0] - point_size, point_center[1] - point_size, point_size * 2, point_size * 2), 3)


        # 頂點標籤
        label_surf = FONT_L.render(label, True, COLORS['black'])
        surface.blit(label_surf, (point_center[0] + 15, point_center[1] - 30))


        # 角度標籤
        if state.toggles['angles']:
            p_prev = p[(i + 1) % 3]
            p_next = p[(i + 2) % 3]
            pos = get_angle_label_pos(pt, p_prev, p_next, 60)
            angle_pos = to_screen(pos)
            
            angle_text = f"{round(angle_values[i])}°"
            angle_surf = FONT_L.render(angle_text, True, COLORS['black'])
            
            shadow_offset = 2
            surface.blit(angle_surf, (angle_pos[0] - angle_surf.get_width() // 2 + shadow_offset, angle_pos[1] - angle_surf.get_height() // 2 + shadow_offset))
            angle_surf = FONT_L.render(angle_text, True, COLORS['yellow']) 
            surface.blit(angle_surf, (angle_pos[0] - angle_surf.get_width() // 2, angle_pos[1] - angle_surf.get_height() // 2))


# 繪製虛線輔助函式 (未變動)
def draw_dashed_line(surf, color, start_pos, end_pos, width, dash_length):
    x1, y1 = start_pos
    x2, y2 = end_pos
    dl = dash_length


    if x1 == x2: # 垂直線
        for i in range(min(y1, y2), max(y1, y2), dl * 2):
            pygame.draw.line(surf, color, (x1, i), (x1, i + dl), width)
    elif y1 == y2: # 水平線
        for i in range(min(x1, x2), max(x1, x2), dl * 2):
            pygame.draw.line(surf, color, (i, y1), (i + dl, y1), width)
    else: # 斜線
        dx = x2 - x1
        dy = y2 - y1
        length = math.sqrt(dx**2 + dy**2)
        
        if length == 0: return


        nx = dx / length
        ny = dy / length


        for i in range(0, int(length), dl * 2):
            start = (int(x1 + nx * i), int(y1 + ny * i))
            end = (int(x1 + nx * (i + dl)), int(y1 + ny * (i + dl)))
            pygame.draw.line(surf, color, start, end, width)


# --- 事件處理 (未變動) ---


def handle_events(state):
    """處理 Pygame 事件，包括拖曳和按鈕點擊"""
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()


        mouse_pos = pygame.mouse.get_pos()
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1: # 左鍵
                for i, pt in enumerate(state.points):
                    point_center_x = pt.x + CANVAS_X
                    point_center_y = pt.y + CANVAS_Y
                    if abs(mouse_pos[0] - point_center_x) < 20 and abs(mouse_pos[1] - point_center_y) < 20:
                        state.dragging_idx = i
                        state.offset_x = pt.x - (mouse_pos[0] - CANVAS_X)
                        state.offset_y = pt.y - (mouse_pos[1] - CANVAS_Y)
                        return


                for key, rect in state.button_rects.items():
                    if rect.collidepoint(mouse_pos):
                        if key in state.toggles:
                            state.toggles[key] = not state.toggles[key]
                        elif key == 'reset':
                            state.reset_points()
                        elif key == 'equilateral':
                            state.set_equilateral()
                        elif key == 'iso_right':
                            state.set_isosceles_right()
                        elif key == 'isosceles':
                            state.set_isosceles()
                        return
                        
        elif event.type == pygame.MOUSEBUTTONUP:
            if event.button == 1:
                state.dragging_idx = None
                
        elif event.type == pygame.MOUSEMOTION:
            if state.dragging_idx is not None:
                new_x = mouse_pos[0] - CANVAS_X + state.offset_x
                new_y = mouse_pos[1] - CANVAS_Y + state.offset_y
                
                new_x = max(0, min(CANVAS_WIDTH, new_x))
                new_y = max(0, min(CANVAS_HEIGHT, new_y))


                state.points[state.dragging_idx].x = new_x
                state.points[state.dragging_idx].y = new_y




def main():
    """主應用程式函式"""
    state = AppState()
    clock = pygame.time.Clock()


    while True:
        handle_events(state)


       
        SCREEN.fill(COLORS['bg'])


        
        draw_ui(SCREEN, state)
        draw_canvas(SCREEN, state)


        
        pygame.display.flip()


        # 控制幀率
        clock.tick(60)


if __name__ == '__main__':
    pygame.display.set_caption("內心程式")
    main()